{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\nconst debug = require('debug');\nconst diver = require('diver');\nconst logger = require('log4js');\nconst alasql = require('alasql');\nfunction SqlToJson(dbClient) {\n  this._debug = debug('SqlToJson');\n  this._logger = logger.getLogger('SqlToJson');\n  this._logger.setLevel('INFO');\n  this._dbClient = dbClient;\n}\nconst p = SqlToJson.prototype;\np.executeGen = function* (struct) {\n  this._debug('executeGen');\n  yield* this._loadDbTables(struct.preLoadTables);\n  this._logger.info('Building JSON structure');\n  const jsonData = yield* this._buildStructureRecursiveGen(struct);\n  this._clearAlaSqlTables();\n  return jsonData;\n};\np._loadDbTables = function* (tablesQueries) {\n  this._debug('_loadDbTables');\n  if (tablesQueries) {\n    this._logger.info('Loading pre load tables');\n    for (let tableName in tablesQueries) {\n      alasql.tables[tableName] = {};\n      let data = yield* this._queryGen(tablesQueries[tableName]);\n      alasql.tables[tableName].data = data;\n    }\n  }\n};\np._clearAlaSqlTables = function () {\n  this._debug('_clearAlaSqlTables');\n  for (let table in alasql.tables) {\n    delete alasql.tables[table];\n  }\n};\np._buildStructureRecursiveGen = function* (struct, reference, value) {\n  this._debug('_buildStructureRecursiveGen', struct, reference, value);\n  this._logger.setLevel(struct.logLevel || 'INFO'); // set the log level for the current level in the struct file\n  let data;\n  if (this._isList(struct.type)) {\n    this._debug('list');\n    if (struct.preDefinedkeys) {\n      for (let i = 0; i < struct.preDefinedkeys.length; i++) {\n        let key = struct.preDefinedkeys[i];\n        let valueDesc = struct.fields[i];\n        let element = yield* this._buildStructureRecursiveGen(valueDesc, reference);\n        this._logger.setLevel(struct.logLevel || 'INFO'); // set back the log level for the current level in the struct file\n        data = this._setElement(data, element, struct.type, key, struct.nullable);\n      }\n    }\n    let dbData = yield* this._fetchDataGen(struct, reference);\n    if (struct.diver) {\n      data = {};\n      for (let i = 0; i < dbData.length; i++) {\n        let dbRow = dbData[i];\n        let newObj = {};\n        for (let j = 0; j < struct.fields.length; j++) {\n          let field = struct.fields[j];\n          let element = yield* this._buildStructureRecursiveGen(field, reference, dbRow[field.dbName]);\n          this._logger.setLevel(struct.logLevel || 'INFO'); // set back the log level for the current level in the struct file\n          newObj = this._setElement(newObj, element, 'object', field.name);\n        }\n        let keys = _.values(dbRow).slice(0, struct.numOfKeys);\n        diver.set(data, keys, newObj);\n      }\n    } else if (dbData && dbData.length > 0) {\n      for (let i = 0; i < dbData.length; i++) {\n        let dbRow = dbData[i];\n        reference = this._getReferenceField(dbRow, struct.refField, reference);\n        for (let j = 0; j < struct.fields.length; j++) {\n          let field = struct.fields[j];\n          let element = yield* this._buildStructureRecursiveGen(field, reference, dbRow[field.dbName]);\n          this._logger.setLevel(struct.logLevel || 'INFO'); // set back the log level for the current level in the struct file\n          let key = dbRow[struct.keyField] || field.name;\n          data = this._setElement(data, element, struct.type, key, field.nullable);\n        }\n      }\n    } else if (_.isEmpty(data) && struct.nullable) {\n      data = this._createElementByType(struct.type);\n      for (let j = 0; j < struct.fields.length; j++) {\n        let field = struct.fields[j];\n        let element = yield* this._buildStructureRecursiveGen(field, reference, null);\n        this._logger.setLevel(struct.logLevel || 'INFO'); // set back the log level for the current level in the struct file\n        let key = field.name;\n        data = this._setElement(data, element, struct.type, key, field.nullable);\n      }\n    }\n  } else if (struct.type === 'json') {\n    this._debug('json');\n    try {\n      data = value ? JSON.parse(value) : '';\n    } catch (e) {\n      data = 'invalid json: ' + value;\n    }\n  } else if (struct.type === 'number') {\n    this._debug('number', value);\n    data = value ? Number(value) : undefined;\n  } else {\n    // for values (string, etc)\n    this._debug('value', value);\n    data = value;\n  }\n  this._logger.setLevel('INFO'); // set back the log level to default\n  return data;\n};\np._fetchDataGen = function* (struct, reference) {\n  this._debug('_fetchDataGen');\n  let dbData = [];\n  if (struct.query) {\n    dbData = yield* this._makeQueries(dbData, struct.query, _.bind(this._queryGen, this), reference);\n  }\n  if (struct.memQuery) {\n    dbData = yield* this._makeQueries(dbData, struct.memQuery, _.bind(this._memQueryGen, this), reference);\n  }\n  this._debug(dbData);\n  return dbData;\n};\np._makeQueries = function* (dbData, queries, queryGen, reference) {\n  this._debug('_makeQueries');\n  if (!_.isArray(queries)) {\n    queries = [queries];\n  }\n  for (var i = 0; i < queries.length; i++) {\n    let query = queries[i];\n    dbData = _.concat(dbData, yield* queryGen(query, reference));\n  }\n  return dbData;\n};\np._memQueryGen = function* (sql, params) {\n  this._debug('_memQueryGen', sql, params);\n  const result = alasql(sql, params);\n  this._printDebug('running memQuery: ' + sql, 'params: ' + params, 'result is: ', result);\n  return result;\n};\np._queryGen = function* (sql, params) {\n  this._debug('_queryGen');\n  let result;\n  try {\n    result = yield _.bind(this._dbClient.query, this._dbClient, sql, _.clone(params));\n  } catch (e) {\n    const error = new Error('Error while query ' + sql + '. ' + e);\n    throw error;\n  }\n  result = result.rows ? result.rows : result;\n  this._printDebug('running query: ' + sql, 'params: ' + params, 'result is: ', result);\n  return result;\n};\np._getReferenceField = function (dbRow, refField, defaultValue) {\n  this._debug('_getReferenceField', arguments);\n  if (!refField) {\n    return defaultValue;\n  }\n  if (!_.isArray(refField)) {\n    refField = [refField];\n  }\n  let ref = [];\n  for (let i = 0; i < refField.length; i++) {\n    ref.push(dbRow[refField[i]]);\n  }\n  this._printDebug('reference is:', ref);\n  return ref;\n};\np._isList = function (type) {\n  this._debug('_isList');\n  return type === 'array' || type === 'object';\n};\np._createElementByType = function (type) {\n  this._debug('_createElementByType');\n  let data;\n  switch (type) {\n    case 'array':\n      return [];\n    case 'object':\n      data = {};\n      return data;\n    default:\n      return undefined;\n  }\n};\np._setElement = function (container, element, containerType, key, nullable) {\n  this._debug('_setElement');\n  if ((element === undefined || element === null) && !nullable) {\n    return container;\n  }\n  this._printDebug('Setting element: ' + element, 'key: ' + key, 'in container: ' + JSON.stringify(container));\n  if (!container) {\n    container = this._createElementByType(containerType);\n  }\n  switch (containerType) {\n    case 'array':\n      if (!element) {\n        return container;\n      }\n      container.push(element);\n      break;\n    case 'object':\n      if (!key) {\n        return container;\n      }\n      if (container[key] !== undefined) {\n        for (let newkey in element) {\n          container[key][newkey] = element[newkey];\n        }\n      } else {\n        container[key] = element;\n      }\n      break;\n    default:\n      // value\n      container = element;\n      break;\n  }\n  return container;\n};\np._printDebug = function () {\n  this._debug('printDebug');\n  for (let i = 0; i < arguments.length; i++) {\n    this._logger.debug(arguments[i]);\n  }\n};\nmodule.exports = SqlToJson;","map":{"version":3,"names":["_","require","debug","diver","logger","alasql","SqlToJson","dbClient","_debug","_logger","getLogger","setLevel","_dbClient","p","prototype","executeGen","struct","_loadDbTables","preLoadTables","info","jsonData","_buildStructureRecursiveGen","_clearAlaSqlTables","tablesQueries","tableName","tables","data","_queryGen","table","reference","value","logLevel","_isList","type","preDefinedkeys","i","length","key","valueDesc","fields","element","_setElement","nullable","dbData","_fetchDataGen","dbRow","newObj","j","field","dbName","name","keys","values","slice","numOfKeys","set","_getReferenceField","refField","keyField","isEmpty","_createElementByType","JSON","parse","e","Number","undefined","query","_makeQueries","bind","memQuery","_memQueryGen","queries","queryGen","isArray","concat","sql","params","result","_printDebug","clone","error","Error","rows","defaultValue","arguments","ref","push","container","containerType","stringify","newkey","module","exports"],"sources":["C:/Users/malvi/Angular/template/node_modules/sql-to-json/lib/SqlToJson.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst debug = require('debug');\nconst diver = require('diver');\nconst logger = require('log4js');\nconst alasql = require('alasql');\n\nfunction SqlToJson(dbClient) {\n\tthis._debug = debug('SqlToJson');\n\tthis._logger = logger.getLogger('SqlToJson');\n\tthis._logger.setLevel('INFO');\n\tthis._dbClient = dbClient;\n}\n\nconst p = SqlToJson.prototype;\n\np.executeGen = function*(struct) {\n\tthis._debug('executeGen');\n\tyield * this._loadDbTables(struct.preLoadTables);\n\tthis._logger.info('Building JSON structure');\n\tconst jsonData = yield * this._buildStructureRecursiveGen(struct);\n\tthis._clearAlaSqlTables();\n\treturn jsonData;\n};\n\np._loadDbTables = function*(tablesQueries) {\n\tthis._debug('_loadDbTables');\n\n\tif (tablesQueries) {\n\t\tthis._logger.info('Loading pre load tables');\n\t\tfor (let tableName in tablesQueries) {\n\t\t\talasql.tables[tableName] = {};\n\t\t\tlet data = yield * this._queryGen(tablesQueries[tableName]);\n\t\t\talasql.tables[tableName].data = data;\n\t\t}\n\n\t}\n};\n\np._clearAlaSqlTables = function() {\n\tthis._debug('_clearAlaSqlTables');\n\tfor (let table in alasql.tables) {\n\t\tdelete alasql.tables[table];\n\t}\n};\n\np._buildStructureRecursiveGen = function*(struct, reference, value) {\n\tthis._debug('_buildStructureRecursiveGen', struct, reference, value);\n\tthis._logger.setLevel(struct.logLevel || 'INFO'); // set the log level for the current level in the struct file\n\tlet data;\n\tif (this._isList(struct.type)) {\n\t\tthis._debug('list');\n\t\tif (struct.preDefinedkeys) {\n\t\t\tfor (let i = 0; i < struct.preDefinedkeys.length; i++) {\n\t\t\t\tlet key = struct.preDefinedkeys[i];\n\t\t\t\tlet valueDesc = struct.fields[i];\n\t\t\t\tlet element = yield * this._buildStructureRecursiveGen(valueDesc, reference);\n\t\t\t\tthis._logger.setLevel(struct.logLevel || 'INFO');// set back the log level for the current level in the struct file\n\t\t\t\tdata = this._setElement(data, element, struct.type, key, struct.nullable);\n\t\t\t}\n\t\t}\n\t\tlet dbData = yield * this._fetchDataGen(struct, reference);\n\t\tif (struct.diver) {\n\t\t\tdata = {};\n\t\t\tfor (let i = 0; i < dbData.length; i++) {\n\t\t\t\tlet dbRow = dbData[i];\n\t\t\t\tlet newObj = {};\n\t\t\t\tfor (let j = 0; j < struct.fields.length; j++) {\n\t\t\t\t\tlet field = struct.fields[j];\n\t\t\t\t\tlet element = yield * this._buildStructureRecursiveGen(field, reference, dbRow[field.dbName]);\n\t\t\t\t\tthis._logger.setLevel(struct.logLevel || 'INFO');// set back the log level for the current level in the struct file\n\t\t\t\t\tnewObj = this._setElement(newObj, element, 'object', field.name);\n\t\t\t\t}\n\t\t\t\tlet keys = _.values(dbRow).slice(0, struct.numOfKeys);\n\t\t\t\tdiver.set(data, keys, newObj);\n\t\t\t}\n\t\t} else if (dbData && dbData.length > 0) {\n\t\t\tfor (let i = 0; i < dbData.length; i++) {\n\t\t\t\tlet dbRow = dbData[i];\n\t\t\t\treference = this._getReferenceField(dbRow, struct.refField, reference);\n\t\t\t\tfor (let j = 0; j < struct.fields.length; j++) {\n\t\t\t\t\tlet field = struct.fields[j];\n\t\t\t\t\tlet element = yield * this._buildStructureRecursiveGen(field, reference, dbRow[field.dbName]);\n\t\t\t\t\tthis._logger.setLevel(struct.logLevel || 'INFO');// set back the log level for the current level in the struct file\n\t\t\t\t\tlet key = dbRow[struct.keyField] || field.name;\n\t\t\t\t\tdata = this._setElement(data, element, struct.type, key, field.nullable);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (_.isEmpty(data) && struct.nullable) {\n\t\t\tdata = this._createElementByType(struct.type);\n\t\t\tfor (let j = 0; j < struct.fields.length; j++) {\n\t\t\t\tlet field = struct.fields[j];\n\t\t\t\tlet element = yield * this._buildStructureRecursiveGen(field, reference, null);\n\t\t\t\tthis._logger.setLevel(struct.logLevel || 'INFO');// set back the log level for the current level in the struct file\n\t\t\t\tlet key = field.name;\n\t\t\t\tdata = this._setElement(data, element, struct.type, key, field.nullable);\n\t\t\t}\n\t\t}\n\t} else if (struct.type === 'json') {\n\t\tthis._debug('json');\n\t\ttry {\n\t\t\tdata = (value ? JSON.parse(value) : '');\n\t\t} catch (e) {\n\t\t\tdata = 'invalid json: ' + value;\n\t\t}\n\t} else if (struct.type === 'number') {\n\t\tthis._debug('number', value);\n\t\tdata = (value ? Number(value) : undefined);\n\t} else { // for values (string, etc)\n\t\tthis._debug('value', value);\n\t\tdata = value;\n\t}\n\tthis._logger.setLevel('INFO');// set back the log level to default\n\treturn data;\n};\n\np._fetchDataGen = function*(struct, reference) {\n\tthis._debug('_fetchDataGen');\n\tlet dbData = [];\n\tif (struct.query) {\n\t\tdbData = yield * this._makeQueries(dbData, struct.query, _.bind(this._queryGen, this), reference);\n\t}\n\tif (struct.memQuery) {\n\t\tdbData = yield * this._makeQueries(dbData, struct.memQuery, _.bind(this._memQueryGen, this), reference);\n\t}\n\tthis._debug(dbData);\n\treturn dbData;\n};\n\np._makeQueries = function*(dbData, queries, queryGen, reference) {\n\tthis._debug('_makeQueries');\n\tif (!_.isArray(queries)) {\n\t\tqueries = [queries];\n\t}\n\tfor (var i = 0; i < queries.length; i++) {\n\t\tlet query = queries[i];\n\t\tdbData = _.concat(dbData, yield * queryGen(query, reference));\n\t}\n\treturn dbData;\n};\n\np._memQueryGen = function*(sql, params) {\n\tthis._debug('_memQueryGen', sql, params);\n\tconst result = alasql(sql, params);\n\tthis._printDebug('running memQuery: ' + sql, 'params: ' + params, 'result is: ', result);\n\treturn result;\n};\n\np._queryGen = function*(sql, params) {\n\tthis._debug('_queryGen');\n\tlet result;\n\ttry {\n\t\tresult = yield _.bind(this._dbClient.query, this._dbClient, sql, _.clone(params));\n\t} catch (e) {\n\t\tconst error = new Error('Error while query ' + sql + '. ' + e);\n\t\tthrow error;\n\t}\n\tresult = (result.rows ? result.rows : result);\n\tthis._printDebug('running query: ' + sql, 'params: ' + params, 'result is: ', result);\n\treturn result;\n};\n\np._getReferenceField = function(dbRow, refField, defaultValue) {\n\tthis._debug('_getReferenceField', arguments);\n\tif (!refField) {\n\t\treturn defaultValue;\n\t}\n\tif (!_.isArray(refField)) {\n\t\trefField = [refField];\n\t}\n\tlet ref = [];\n\tfor (let i = 0; i < refField.length; i++) {\n\t\tref.push(dbRow[refField[i]]);\n\t}\n\tthis._printDebug('reference is:', ref);\n\treturn ref;\n};\n\np._isList = function(type) {\n\tthis._debug('_isList');\n\treturn (type === 'array' || type === 'object');\n};\n\np._createElementByType = function(type) {\n\tthis._debug('_createElementByType');\n\tlet data;\n\tswitch (type) {\n\t\tcase ('array'):\n\t\t\treturn [];\n\t\tcase ('object'):\n\t\t\tdata = {};\n\t\t\treturn data;\n\t\tdefault:\n\t\t\treturn undefined;\n\t}\n};\n\np._setElement = function(container, element, containerType, key, nullable) {\n\tthis._debug('_setElement');\n\tif ((element === undefined || element === null) && !nullable) {\n\t\treturn container;\n\t}\n\tthis._printDebug('Setting element: ' + element, 'key: ' + key, 'in container: ' + JSON.stringify(container));\n\tif (!container) {\n\t\tcontainer = this._createElementByType(containerType);\n\t}\n\tswitch (containerType) {\n\t\tcase ('array'):\n\t\t\tif (!element) {\n\t\t\t\treturn container;\n\t\t\t}\n\t\t\tcontainer.push(element);\n\t\t\tbreak;\n\t\tcase ('object'):\n\t\t\tif (!key) {\n\t\t\t\treturn container;\n\t\t\t}\n\t\t\tif (container[key] !== undefined) {\n\t\t\t\tfor (let newkey in element) {\n\t\t\t\t\tcontainer[key][newkey] = element[newkey];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontainer[key] = element;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault: // value\n\t\t\tcontainer = element;\n\t\t\tbreak;\n\t}\n\treturn container;\n};\n\np._printDebug = function() {\n\tthis._debug('printDebug');\n\tfor (let i = 0; i < arguments.length; i++) {\n\t\tthis._logger.debug(arguments[i]);\n\t}\n}\n\nmodule.exports = SqlToJson;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
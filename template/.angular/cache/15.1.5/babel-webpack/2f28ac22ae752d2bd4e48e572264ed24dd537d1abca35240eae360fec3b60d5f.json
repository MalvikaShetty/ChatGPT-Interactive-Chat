{"ast":null,"code":"\"use strict\";\n\nvar log4js = require('../log4js'),\n  net = require('net'),\n  END_MSG = '__LOG4JS__';\n\n/**\n * Creates a server, listening on config.loggerPort, config.loggerHost.\n * Output goes to config.actualAppender (config.appender is used to\n * set up that appender).\n */\nfunction logServer(config) {\n  /**\n   * Takes a utf-8 string, returns an object with\n   * the correct log properties.\n   */\n  function deserializeLoggingEvent(clientSocket, msg) {\n    var loggingEvent;\n    try {\n      loggingEvent = JSON.parse(msg);\n      loggingEvent.startTime = new Date(loggingEvent.startTime);\n      loggingEvent.level = log4js.levels.toLevel(loggingEvent.level.levelStr);\n    } catch (e) {\n      // JSON.parse failed, just log the contents probably a naughty.\n      loggingEvent = {\n        startTime: new Date(),\n        categoryName: 'log4js',\n        level: log4js.levels.ERROR,\n        data: ['Unable to parse log:', msg]\n      };\n    }\n    loggingEvent.remoteAddress = clientSocket.remoteAddress;\n    loggingEvent.remotePort = clientSocket.remotePort;\n    return loggingEvent;\n  }\n  var actualAppender = config.actualAppender,\n    server = net.createServer(function serverCreated(clientSocket) {\n      clientSocket.setEncoding('utf8');\n      var logMessage = '';\n      function logTheMessage(msg) {\n        if (logMessage.length > 0) {\n          actualAppender(deserializeLoggingEvent(clientSocket, msg));\n        }\n      }\n      function chunkReceived(chunk) {\n        var event;\n        logMessage += chunk || '';\n        if (logMessage.indexOf(END_MSG) > -1) {\n          event = logMessage.substring(0, logMessage.indexOf(END_MSG));\n          logTheMessage(event);\n          logMessage = logMessage.substring(event.length + END_MSG.length) || '';\n          //check for more, maybe it was a big chunk\n          chunkReceived();\n        }\n      }\n      clientSocket.on('data', chunkReceived);\n      clientSocket.on('end', chunkReceived);\n    });\n  server.listen(config.loggerPort || 5000, config.loggerHost || 'localhost');\n  return actualAppender;\n}\nfunction workerAppender(config) {\n  var canWrite = false,\n    buffer = [],\n    socket;\n  createSocket();\n  function createSocket() {\n    socket = net.createConnection(config.loggerPort || 5000, config.loggerHost || 'localhost');\n    socket.on('connect', function () {\n      emptyBuffer();\n      canWrite = true;\n    });\n    socket.on('timeout', socket.end.bind(socket));\n    //don't bother listening for 'error', 'close' gets called after that anyway\n    socket.on('close', createSocket);\n  }\n  function emptyBuffer() {\n    var evt;\n    while (evt = buffer.shift()) {\n      write(evt);\n    }\n  }\n  function write(loggingEvent) {\n    // JSON.stringify(new Error('test')) returns {}, which is not really useful for us.\n    // The following allows us to serialize errors correctly.\n    if (loggingEvent && loggingEvent.stack && JSON.stringify(loggingEvent) === '{}') {\n      // Validate that we really are in this case\n      loggingEvent = {\n        stack: loggingEvent.stack\n      };\n    }\n    socket.write(JSON.stringify(loggingEvent), 'utf8');\n    socket.write(END_MSG, 'utf8');\n  }\n  return function log(loggingEvent) {\n    if (canWrite) {\n      write(loggingEvent);\n    } else {\n      buffer.push(loggingEvent);\n    }\n  };\n}\nfunction createAppender(config) {\n  if (config.mode === 'master') {\n    return logServer(config);\n  } else {\n    return workerAppender(config);\n  }\n}\nfunction configure(config, options) {\n  var actualAppender;\n  if (config.appender && config.mode === 'master') {\n    log4js.loadAppender(config.appender.type);\n    actualAppender = log4js.appenderMakers[config.appender.type](config.appender, options);\n    config.actualAppender = actualAppender;\n  }\n  return createAppender(config);\n}\nexports.appender = createAppender;\nexports.configure = configure;","map":{"version":3,"names":["log4js","require","net","END_MSG","logServer","config","deserializeLoggingEvent","clientSocket","msg","loggingEvent","JSON","parse","startTime","Date","level","levels","toLevel","levelStr","e","categoryName","ERROR","data","remoteAddress","remotePort","actualAppender","server","createServer","serverCreated","setEncoding","logMessage","logTheMessage","length","chunkReceived","chunk","event","indexOf","substring","on","listen","loggerPort","loggerHost","workerAppender","canWrite","buffer","socket","createSocket","createConnection","emptyBuffer","end","bind","evt","shift","write","stack","stringify","log","push","createAppender","mode","configure","options","appender","loadAppender","type","appenderMakers","exports"],"sources":["C:/Users/malvi/Angular/template/node_modules/sql-to-json/node_modules/log4js/lib/appenders/multiprocess.js"],"sourcesContent":["\"use strict\";\nvar log4js = require('../log4js')\n, net = require('net')\n, END_MSG = '__LOG4JS__';\n\n/**\n * Creates a server, listening on config.loggerPort, config.loggerHost.\n * Output goes to config.actualAppender (config.appender is used to\n * set up that appender).\n */\nfunction logServer(config) {\n  \n  /**\n   * Takes a utf-8 string, returns an object with\n   * the correct log properties.\n   */\n  function deserializeLoggingEvent(clientSocket, msg) {\n    var loggingEvent;\n    try {\n      loggingEvent = JSON.parse(msg);\n      loggingEvent.startTime = new Date(loggingEvent.startTime);\n      loggingEvent.level = log4js.levels.toLevel(loggingEvent.level.levelStr);\n    } catch (e) {\n      // JSON.parse failed, just log the contents probably a naughty.\n      loggingEvent = {\n        startTime: new Date(),\n        categoryName: 'log4js',\n        level: log4js.levels.ERROR,\n        data: [ 'Unable to parse log:', msg ]\n      };\n    }\n\n    loggingEvent.remoteAddress = clientSocket.remoteAddress;\n    loggingEvent.remotePort = clientSocket.remotePort;\n    \n    return loggingEvent;\n  }\n  \n  var actualAppender = config.actualAppender,\n  server = net.createServer(function serverCreated(clientSocket) {\n    clientSocket.setEncoding('utf8');\n    var logMessage = '';\n    \n    function logTheMessage(msg) {\n      if (logMessage.length > 0) {\n        actualAppender(deserializeLoggingEvent(clientSocket, msg));\n      }\n    }\n    \n    function chunkReceived(chunk) {\n      var event;\n      logMessage += chunk || '';\n      if (logMessage.indexOf(END_MSG) > -1) {\n        event = logMessage.substring(0, logMessage.indexOf(END_MSG));\n        logTheMessage(event);\n        logMessage = logMessage.substring(event.length + END_MSG.length) || '';\n        //check for more, maybe it was a big chunk\n        chunkReceived();\n      }\n    }\n    \n    clientSocket.on('data', chunkReceived);\n    clientSocket.on('end', chunkReceived);\n  });\n  \n  server.listen(config.loggerPort || 5000, config.loggerHost || 'localhost');\n  \n  return actualAppender;\n}\n\nfunction workerAppender(config) {\n  var canWrite = false,\n  buffer = [],\n  socket;\n  \n  createSocket();\n  \n  function createSocket() {\n    socket = net.createConnection(config.loggerPort || 5000, config.loggerHost || 'localhost');\n    socket.on('connect', function() {\n      emptyBuffer();\n      canWrite = true;\n    });\n    socket.on('timeout', socket.end.bind(socket));\n    //don't bother listening for 'error', 'close' gets called after that anyway\n    socket.on('close', createSocket);\n  }\n  \n  function emptyBuffer() {\n    var evt;\n    while ((evt = buffer.shift())) {\n      write(evt);\n    }\n  }\n  \n  function write(loggingEvent) {\n\t// JSON.stringify(new Error('test')) returns {}, which is not really useful for us.\n\t// The following allows us to serialize errors correctly.\n\tif (loggingEvent && loggingEvent.stack && JSON.stringify(loggingEvent) === '{}') { // Validate that we really are in this case\n\t\tloggingEvent = {stack : loggingEvent.stack};\n\t}\n    socket.write(JSON.stringify(loggingEvent), 'utf8');\n    socket.write(END_MSG, 'utf8');\n  }\n  \n  return function log(loggingEvent) {\n    if (canWrite) {\n      write(loggingEvent);\n    } else {\n      buffer.push(loggingEvent);\n    }\n  };\n}\n\nfunction createAppender(config) {\n  if (config.mode === 'master') {\n    return logServer(config);\n  } else {\n    return workerAppender(config);\n  }\n}\n\nfunction configure(config, options) {\n  var actualAppender;\n  if (config.appender && config.mode === 'master') {\n    log4js.loadAppender(config.appender.type);\n    actualAppender = log4js.appenderMakers[config.appender.type](config.appender, options);\n    config.actualAppender = actualAppender;\n  }\n  return createAppender(config);\n}\n\nexports.appender = createAppender;\nexports.configure = configure;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"\"use strict\";\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) {\n        ;\n      }\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nvar _require = require(\"./errors.js\"),\n  getUnclosedTagException = _require.getUnclosedTagException,\n  getUnopenedTagException = _require.getUnopenedTagException,\n  getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\n  getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\n  throwMalformedXml = _require.throwMalformedXml,\n  throwXmlInvalid = _require.throwXmlInvalid,\n  XTTemplateError = _require.XTTemplateError;\nvar _require2 = require(\"./doc-utils.js\"),\n  isTextStart = _require2.isTextStart,\n  isTextEnd = _require2.isTextEnd,\n  wordToUtf8 = _require2.wordToUtf8;\nvar DELIMITER_NONE = 0,\n  DELIMITER_EQUAL = 1,\n  DELIMITER_START = 2,\n  DELIMITER_END = 3;\nfunction inRange(range, match) {\n  return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n  if (isTextStart(part)) {\n    if (inTextTag) {\n      throwMalformedXml();\n    }\n    return true;\n  }\n  if (isTextEnd(part)) {\n    if (!inTextTag) {\n      throwMalformedXml();\n    }\n    return false;\n  }\n  return inTextTag;\n}\nfunction getTag(tag) {\n  var position = \"\";\n  var start = 1;\n  var end = tag.indexOf(\" \");\n  if (tag[tag.length - 2] === \"/\") {\n    position = \"selfclosing\";\n    if (end === -1) {\n      end = tag.length - 2;\n    }\n  } else if (tag[1] === \"/\") {\n    start = 2;\n    position = \"end\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  } else {\n    position = \"start\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  }\n  return {\n    tag: tag.slice(start, end),\n    position: position\n  };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n  var cursor = 0;\n  var contentLength = content.length;\n  var allMatches = {};\n  for (var i = 0, len = textMatchArray.length; i < len; i++) {\n    allMatches[textMatchArray[i]] = true;\n  }\n  for (var _i = 0, _len = othersMatchArray.length; _i < _len; _i++) {\n    allMatches[othersMatchArray[_i]] = false;\n  }\n  var totalMatches = [];\n  while (cursor < contentLength) {\n    cursor = content.indexOf(\"<\", cursor);\n    if (cursor === -1) {\n      break;\n    }\n    var offset = cursor;\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\n    cursor = content.indexOf(\">\", cursor);\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n      throwXmlInvalid(content, offset);\n    }\n    var tagText = content.slice(offset, cursor + 1);\n    var _getTag = getTag(tagText),\n      tag = _getTag.tag,\n      position = _getTag.position;\n    var text = allMatches[tag];\n    if (text == null) {\n      continue;\n    }\n    totalMatches.push({\n      type: \"tag\",\n      position: position,\n      text: text,\n      offset: offset,\n      value: tagText,\n      tag: tag\n    });\n  }\n  return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText) {\n  var errors = [];\n  var inDelimiter = false;\n  var lastDelimiterMatch = {\n    offset: 0\n  };\n  var xtag;\n  delimiterMatches.forEach(function (delimiterMatch) {\n    xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\n    if (delimiterMatch.position === \"start\" && inDelimiter || delimiterMatch.position === \"end\" && !inDelimiter) {\n      if (delimiterMatch.position === \"start\") {\n        if (lastDelimiterMatch.offset + lastDelimiterMatch.length === delimiterMatch.offset) {\n          xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset + lastDelimiterMatch.length + 4);\n          errors.push(getDuplicateOpenTagException({\n            xtag: xtag,\n            offset: lastDelimiterMatch.offset\n          }));\n        } else {\n          errors.push(getUnclosedTagException({\n            xtag: wordToUtf8(xtag),\n            offset: lastDelimiterMatch.offset\n          }));\n        }\n        delimiterMatch.error = true;\n      } else {\n        if (lastDelimiterMatch.offset + lastDelimiterMatch.length === delimiterMatch.offset) {\n          xtag = fullText.substr(lastDelimiterMatch.offset - 4, delimiterMatch.offset - lastDelimiterMatch.offset + 4 + lastDelimiterMatch.length);\n          errors.push(getDuplicateCloseTagException({\n            xtag: xtag,\n            offset: lastDelimiterMatch.offset\n          }));\n        } else {\n          errors.push(getUnopenedTagException({\n            xtag: xtag,\n            offset: delimiterMatch.offset\n          }));\n        }\n        delimiterMatch.error = true;\n      }\n    } else {\n      inDelimiter = !inDelimiter;\n    }\n    lastDelimiterMatch = delimiterMatch;\n  });\n  var delimiterMatch = {\n    offset: fullText.length\n  };\n  xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\n  if (inDelimiter) {\n    errors.push(getUnclosedTagException({\n      xtag: wordToUtf8(xtag),\n      offset: lastDelimiterMatch.offset\n    }));\n    delimiterMatch.error = true;\n  }\n  return errors;\n}\nfunction compareOffsets(startOffset, endOffset) {\n  if (startOffset === -1 && endOffset === -1) {\n    return DELIMITER_NONE;\n  }\n  if (startOffset === endOffset) {\n    return DELIMITER_EQUAL;\n  }\n  if (startOffset === -1 || endOffset === -1) {\n    return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n  }\n  return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n  var newDelimiters = inside.split(\" \");\n  if (newDelimiters.length !== 2) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\n    start = _newDelimiters[0],\n    end = _newDelimiters[1];\n  if (start.length === 0 || end.length === 0) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  return [start, end];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters) {\n  var indexes = [];\n  var start = delimiters.start,\n    end = delimiters.end;\n  var offset = -1;\n  var insideTag = false;\n  while (true) {\n    var startOffset = fullText.indexOf(start, offset + 1);\n    var endOffset = fullText.indexOf(end, offset + 1);\n    var position = null;\n    var len = void 0;\n    var compareResult = compareOffsets(startOffset, endOffset);\n    if (compareResult === DELIMITER_EQUAL) {\n      compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n    }\n    switch (compareResult) {\n      case DELIMITER_NONE:\n        return indexes;\n      case DELIMITER_END:\n        insideTag = false;\n        offset = endOffset;\n        position = \"end\";\n        len = end.length;\n        break;\n      case DELIMITER_START:\n        insideTag = true;\n        offset = startOffset;\n        position = \"start\";\n        len = start.length;\n        break;\n    }\n    // if tag starts with =, such as {=[ ]=}\n    if (compareResult === DELIMITER_START && fullText[offset + start.length] === \"=\") {\n      indexes.push({\n        offset: startOffset,\n        position: \"start\",\n        length: start.length,\n        changedelimiter: true\n      });\n      var nextEqual = fullText.indexOf(\"=\", offset + start.length + 1);\n      var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n      indexes.push({\n        offset: nextEndOffset,\n        position: \"end\",\n        length: end.length,\n        changedelimiter: true\n      });\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n      var _splitDelimiters = splitDelimiters(_insideTag);\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n      start = _splitDelimiters2[0];\n      end = _splitDelimiters2[1];\n      offset = nextEndOffset;\n      continue;\n    }\n    indexes.push({\n      offset: offset,\n      position: position,\n      length: len\n    });\n  }\n}\nfunction parseDelimiters(innerContentParts, delimiters) {\n  var full = innerContentParts.map(function (p) {\n    return p.value;\n  }).join(\"\");\n  var delimiterMatches = getAllDelimiterIndexes(full, delimiters);\n  var offset = 0;\n  var ranges = innerContentParts.map(function (part) {\n    offset += part.value.length;\n    return {\n      offset: offset - part.value.length,\n      lIndex: part.lIndex\n    };\n  });\n  var errors = getDelimiterErrors(delimiterMatches, full, ranges);\n  var cutNext = 0;\n  var delimiterIndex = 0;\n  var parsed = ranges.map(function (p, i) {\n    var offset = p.offset;\n    var range = [offset, offset + innerContentParts[i].value.length];\n    var partContent = innerContentParts[i].value;\n    var delimitersInOffset = [];\n    while (delimiterIndex < delimiterMatches.length && inRange(range, delimiterMatches[delimiterIndex])) {\n      delimitersInOffset.push(delimiterMatches[delimiterIndex]);\n      delimiterIndex++;\n    }\n    var parts = [];\n    var cursor = 0;\n    if (cutNext > 0) {\n      cursor = cutNext;\n      cutNext = 0;\n    }\n    delimitersInOffset.forEach(function (delimiterInOffset) {\n      var value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n      if (delimiterInOffset.changedelimiter) {\n        if (delimiterInOffset.position === \"start\") {\n          if (value.length > 0) {\n            parts.push({\n              type: \"content\",\n              value: value\n            });\n          }\n        } else {\n          cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        }\n        return;\n      }\n      if (value.length > 0) {\n        parts.push({\n          type: \"content\",\n          value: value\n        });\n        cursor += value.length;\n      }\n      var delimiterPart = {\n        type: \"delimiter\",\n        position: delimiterInOffset.position,\n        offset: cursor + offset\n      };\n      parts.push(delimiterPart);\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n    });\n    cutNext = cursor - partContent.length;\n    var value = partContent.substr(cursor);\n    if (value.length > 0) {\n      parts.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parts;\n  }, this);\n  return {\n    parsed: parsed,\n    errors: errors\n  };\n}\nfunction isInsideContent(part) {\n  // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n  return part.type === \"content\" && part.position === \"insidetag\";\n  // Stryker restore all\n}\n\nfunction getContentParts(xmlparsed) {\n  return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed) {\n  var inTextTag = false;\n  xmlparsed.forEach(function (part) {\n    inTextTag = updateInTextTag(part, inTextTag);\n    if (part.type === \"content\") {\n      part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n    }\n    if (isInsideContent(part)) {\n      part.value = part.value.replace(/>/g, \"&gt;\");\n    }\n  });\n}\nmodule.exports = {\n  parseDelimiters: parseDelimiters,\n  parse: function parse(xmlparsed, delimiters) {\n    decodeContentParts(xmlparsed);\n    var _parseDelimiters = parseDelimiters(getContentParts(xmlparsed), delimiters),\n      delimiterParsed = _parseDelimiters.parsed,\n      errors = _parseDelimiters.errors;\n    var lexed = [];\n    var index = 0;\n    var lIndex = 0;\n    xmlparsed.forEach(function (part) {\n      if (isInsideContent(part)) {\n        Array.prototype.push.apply(lexed, delimiterParsed[index].map(function (p) {\n          if (p.type === \"content\") {\n            p.position = \"insidetag\";\n          }\n          p.lIndex = lIndex++;\n          return p;\n        }));\n        index++;\n      } else {\n        part.lIndex = lIndex++;\n        lexed.push(part);\n      }\n    });\n    return {\n      errors: errors,\n      lexed: lexed\n    };\n  },\n  xmlparse: function xmlparse(content, xmltags) {\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\n    var cursor = 0;\n    var parsed = matches.reduce(function (parsed, match) {\n      var value = content.substr(cursor, match.offset - cursor);\n      if (value.length > 0) {\n        parsed.push({\n          type: \"content\",\n          value: value\n        });\n      }\n      cursor = match.offset + match.value.length;\n      delete match.offset;\n      parsed.push(match);\n      return parsed;\n    }, []);\n    var value = content.substr(cursor);\n    if (value.length > 0) {\n      parsed.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parsed;\n  }\n};","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","isArray","_require","require","getUnclosedTagException","getUnopenedTagException","getDuplicateOpenTagException","getDuplicateCloseTagException","throwMalformedXml","throwXmlInvalid","XTTemplateError","_require2","isTextStart","isTextEnd","wordToUtf8","DELIMITER_NONE","DELIMITER_EQUAL","DELIMITER_START","DELIMITER_END","inRange","range","match","offset","updateInTextTag","part","inTextTag","getTag","tag","position","start","end","indexOf","tagMatcher","content","textMatchArray","othersMatchArray","cursor","contentLength","allMatches","_len","totalMatches","nextOpening","tagText","_getTag","text","type","getDelimiterErrors","delimiterMatches","fullText","errors","inDelimiter","lastDelimiterMatch","xtag","forEach","delimiterMatch","substr","error","compareOffsets","startOffset","endOffset","splitDelimiters","inside","newDelimiters","split","properties","id","explanation","_newDelimiters","getAllDelimiterIndexes","delimiters","indexes","insideTag","compareResult","changedelimiter","nextEqual","nextEndOffset","_insideTag","_splitDelimiters","_splitDelimiters2","parseDelimiters","innerContentParts","full","map","p","join","ranges","lIndex","cutNext","delimiterIndex","parsed","partContent","delimitersInOffset","parts","delimiterInOffset","delimiterPart","isInsideContent","getContentParts","xmlparsed","filter","decodeContentParts","replace","module","exports","parse","_parseDelimiters","delimiterParsed","lexed","index","apply","xmlparse","xmltags","matches","other","reduce"],"sources":["C:/Users/malvi/Angular/template/node_modules/docxtemplater/js/lexer.js"],"sourcesContent":["\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar _require = require(\"./errors.js\"),\n  getUnclosedTagException = _require.getUnclosedTagException,\n  getUnopenedTagException = _require.getUnopenedTagException,\n  getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\n  getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\n  throwMalformedXml = _require.throwMalformedXml,\n  throwXmlInvalid = _require.throwXmlInvalid,\n  XTTemplateError = _require.XTTemplateError;\nvar _require2 = require(\"./doc-utils.js\"),\n  isTextStart = _require2.isTextStart,\n  isTextEnd = _require2.isTextEnd,\n  wordToUtf8 = _require2.wordToUtf8;\nvar DELIMITER_NONE = 0,\n  DELIMITER_EQUAL = 1,\n  DELIMITER_START = 2,\n  DELIMITER_END = 3;\nfunction inRange(range, match) {\n  return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n  if (isTextStart(part)) {\n    if (inTextTag) {\n      throwMalformedXml();\n    }\n    return true;\n  }\n  if (isTextEnd(part)) {\n    if (!inTextTag) {\n      throwMalformedXml();\n    }\n    return false;\n  }\n  return inTextTag;\n}\nfunction getTag(tag) {\n  var position = \"\";\n  var start = 1;\n  var end = tag.indexOf(\" \");\n  if (tag[tag.length - 2] === \"/\") {\n    position = \"selfclosing\";\n    if (end === -1) {\n      end = tag.length - 2;\n    }\n  } else if (tag[1] === \"/\") {\n    start = 2;\n    position = \"end\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  } else {\n    position = \"start\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  }\n  return {\n    tag: tag.slice(start, end),\n    position: position\n  };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n  var cursor = 0;\n  var contentLength = content.length;\n  var allMatches = {};\n  for (var i = 0, len = textMatchArray.length; i < len; i++) {\n    allMatches[textMatchArray[i]] = true;\n  }\n  for (var _i = 0, _len = othersMatchArray.length; _i < _len; _i++) {\n    allMatches[othersMatchArray[_i]] = false;\n  }\n  var totalMatches = [];\n  while (cursor < contentLength) {\n    cursor = content.indexOf(\"<\", cursor);\n    if (cursor === -1) {\n      break;\n    }\n    var offset = cursor;\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\n    cursor = content.indexOf(\">\", cursor);\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n      throwXmlInvalid(content, offset);\n    }\n    var tagText = content.slice(offset, cursor + 1);\n    var _getTag = getTag(tagText),\n      tag = _getTag.tag,\n      position = _getTag.position;\n    var text = allMatches[tag];\n    if (text == null) {\n      continue;\n    }\n    totalMatches.push({\n      type: \"tag\",\n      position: position,\n      text: text,\n      offset: offset,\n      value: tagText,\n      tag: tag\n    });\n  }\n  return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText) {\n  var errors = [];\n  var inDelimiter = false;\n  var lastDelimiterMatch = {\n    offset: 0\n  };\n  var xtag;\n  delimiterMatches.forEach(function (delimiterMatch) {\n    xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\n    if (delimiterMatch.position === \"start\" && inDelimiter || delimiterMatch.position === \"end\" && !inDelimiter) {\n      if (delimiterMatch.position === \"start\") {\n        if (lastDelimiterMatch.offset + lastDelimiterMatch.length === delimiterMatch.offset) {\n          xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset + lastDelimiterMatch.length + 4);\n          errors.push(getDuplicateOpenTagException({\n            xtag: xtag,\n            offset: lastDelimiterMatch.offset\n          }));\n        } else {\n          errors.push(getUnclosedTagException({\n            xtag: wordToUtf8(xtag),\n            offset: lastDelimiterMatch.offset\n          }));\n        }\n        delimiterMatch.error = true;\n      } else {\n        if (lastDelimiterMatch.offset + lastDelimiterMatch.length === delimiterMatch.offset) {\n          xtag = fullText.substr(lastDelimiterMatch.offset - 4, delimiterMatch.offset - lastDelimiterMatch.offset + 4 + lastDelimiterMatch.length);\n          errors.push(getDuplicateCloseTagException({\n            xtag: xtag,\n            offset: lastDelimiterMatch.offset\n          }));\n        } else {\n          errors.push(getUnopenedTagException({\n            xtag: xtag,\n            offset: delimiterMatch.offset\n          }));\n        }\n        delimiterMatch.error = true;\n      }\n    } else {\n      inDelimiter = !inDelimiter;\n    }\n    lastDelimiterMatch = delimiterMatch;\n  });\n  var delimiterMatch = {\n    offset: fullText.length\n  };\n  xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\n  if (inDelimiter) {\n    errors.push(getUnclosedTagException({\n      xtag: wordToUtf8(xtag),\n      offset: lastDelimiterMatch.offset\n    }));\n    delimiterMatch.error = true;\n  }\n  return errors;\n}\nfunction compareOffsets(startOffset, endOffset) {\n  if (startOffset === -1 && endOffset === -1) {\n    return DELIMITER_NONE;\n  }\n  if (startOffset === endOffset) {\n    return DELIMITER_EQUAL;\n  }\n  if (startOffset === -1 || endOffset === -1) {\n    return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n  }\n  return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n  var newDelimiters = inside.split(\" \");\n  if (newDelimiters.length !== 2) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\n    start = _newDelimiters[0],\n    end = _newDelimiters[1];\n  if (start.length === 0 || end.length === 0) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  return [start, end];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters) {\n  var indexes = [];\n  var start = delimiters.start,\n    end = delimiters.end;\n  var offset = -1;\n  var insideTag = false;\n  while (true) {\n    var startOffset = fullText.indexOf(start, offset + 1);\n    var endOffset = fullText.indexOf(end, offset + 1);\n    var position = null;\n    var len = void 0;\n    var compareResult = compareOffsets(startOffset, endOffset);\n    if (compareResult === DELIMITER_EQUAL) {\n      compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n    }\n    switch (compareResult) {\n      case DELIMITER_NONE:\n        return indexes;\n      case DELIMITER_END:\n        insideTag = false;\n        offset = endOffset;\n        position = \"end\";\n        len = end.length;\n        break;\n      case DELIMITER_START:\n        insideTag = true;\n        offset = startOffset;\n        position = \"start\";\n        len = start.length;\n        break;\n    }\n    // if tag starts with =, such as {=[ ]=}\n    if (compareResult === DELIMITER_START && fullText[offset + start.length] === \"=\") {\n      indexes.push({\n        offset: startOffset,\n        position: \"start\",\n        length: start.length,\n        changedelimiter: true\n      });\n      var nextEqual = fullText.indexOf(\"=\", offset + start.length + 1);\n      var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n      indexes.push({\n        offset: nextEndOffset,\n        position: \"end\",\n        length: end.length,\n        changedelimiter: true\n      });\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n      var _splitDelimiters = splitDelimiters(_insideTag);\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n      start = _splitDelimiters2[0];\n      end = _splitDelimiters2[1];\n      offset = nextEndOffset;\n      continue;\n    }\n    indexes.push({\n      offset: offset,\n      position: position,\n      length: len\n    });\n  }\n}\nfunction parseDelimiters(innerContentParts, delimiters) {\n  var full = innerContentParts.map(function (p) {\n    return p.value;\n  }).join(\"\");\n  var delimiterMatches = getAllDelimiterIndexes(full, delimiters);\n  var offset = 0;\n  var ranges = innerContentParts.map(function (part) {\n    offset += part.value.length;\n    return {\n      offset: offset - part.value.length,\n      lIndex: part.lIndex\n    };\n  });\n  var errors = getDelimiterErrors(delimiterMatches, full, ranges);\n  var cutNext = 0;\n  var delimiterIndex = 0;\n  var parsed = ranges.map(function (p, i) {\n    var offset = p.offset;\n    var range = [offset, offset + innerContentParts[i].value.length];\n    var partContent = innerContentParts[i].value;\n    var delimitersInOffset = [];\n    while (delimiterIndex < delimiterMatches.length && inRange(range, delimiterMatches[delimiterIndex])) {\n      delimitersInOffset.push(delimiterMatches[delimiterIndex]);\n      delimiterIndex++;\n    }\n    var parts = [];\n    var cursor = 0;\n    if (cutNext > 0) {\n      cursor = cutNext;\n      cutNext = 0;\n    }\n    delimitersInOffset.forEach(function (delimiterInOffset) {\n      var value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n      if (delimiterInOffset.changedelimiter) {\n        if (delimiterInOffset.position === \"start\") {\n          if (value.length > 0) {\n            parts.push({\n              type: \"content\",\n              value: value\n            });\n          }\n        } else {\n          cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        }\n        return;\n      }\n      if (value.length > 0) {\n        parts.push({\n          type: \"content\",\n          value: value\n        });\n        cursor += value.length;\n      }\n      var delimiterPart = {\n        type: \"delimiter\",\n        position: delimiterInOffset.position,\n        offset: cursor + offset\n      };\n      parts.push(delimiterPart);\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n    });\n    cutNext = cursor - partContent.length;\n    var value = partContent.substr(cursor);\n    if (value.length > 0) {\n      parts.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parts;\n  }, this);\n  return {\n    parsed: parsed,\n    errors: errors\n  };\n}\nfunction isInsideContent(part) {\n  // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n  return part.type === \"content\" && part.position === \"insidetag\";\n  // Stryker restore all\n}\n\nfunction getContentParts(xmlparsed) {\n  return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed) {\n  var inTextTag = false;\n  xmlparsed.forEach(function (part) {\n    inTextTag = updateInTextTag(part, inTextTag);\n    if (part.type === \"content\") {\n      part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n    }\n    if (isInsideContent(part)) {\n      part.value = part.value.replace(/>/g, \"&gt;\");\n    }\n  });\n}\nmodule.exports = {\n  parseDelimiters: parseDelimiters,\n  parse: function parse(xmlparsed, delimiters) {\n    decodeContentParts(xmlparsed);\n    var _parseDelimiters = parseDelimiters(getContentParts(xmlparsed), delimiters),\n      delimiterParsed = _parseDelimiters.parsed,\n      errors = _parseDelimiters.errors;\n    var lexed = [];\n    var index = 0;\n    var lIndex = 0;\n    xmlparsed.forEach(function (part) {\n      if (isInsideContent(part)) {\n        Array.prototype.push.apply(lexed, delimiterParsed[index].map(function (p) {\n          if (p.type === \"content\") {\n            p.position = \"insidetag\";\n          }\n          p.lIndex = lIndex++;\n          return p;\n        }));\n        index++;\n      } else {\n        part.lIndex = lIndex++;\n        lexed.push(part);\n      }\n    });\n    return {\n      errors: errors,\n      lexed: lexed\n    };\n  },\n  xmlparse: function xmlparse(content, xmltags) {\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\n    var cursor = 0;\n    var parsed = matches.reduce(function (parsed, match) {\n      var value = content.substr(cursor, match.offset - cursor);\n      if (value.length > 0) {\n        parsed.push({\n          type: \"content\",\n          value: value\n        });\n      }\n      cursor = match.offset + match.value.length;\n      delete match.offset;\n      parsed.push(match);\n      return parsed;\n    }, []);\n    var value = content.substr(cursor);\n    if (value.length > 0) {\n      parsed.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parsed;\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
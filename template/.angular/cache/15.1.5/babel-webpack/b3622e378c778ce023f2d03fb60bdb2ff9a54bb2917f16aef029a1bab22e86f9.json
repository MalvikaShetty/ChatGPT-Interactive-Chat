{"ast":null,"code":"\"use strict\";\n\nvar cluster = require('cluster');\nvar log4js = require('../log4js');\n\n/**\n * Takes a loggingEvent object, returns string representation of it.\n */\nfunction serializeLoggingEvent(loggingEvent) {\n  // JSON.stringify(new Error('test')) returns {}, which is not really useful for us.\n  // The following allows us to serialize errors correctly.\n  for (var i = 0; i < loggingEvent.data.length; i++) {\n    var item = loggingEvent.data[i];\n    if (item && item.stack && JSON.stringify(item) === '{}') {\n      // Validate that we really are in this case\n      loggingEvent.data[i] = {\n        stack: item.stack\n      };\n    }\n  }\n  return JSON.stringify(loggingEvent);\n}\n\n/**\n * Takes a string, returns an object with\n * the correct log properties.\n *\n * This method has been \"borrowed\" from the `multiprocess` appender \n * by `nomiddlename` (https://github.com/nomiddlename/log4js-node/blob/master/lib/appenders/multiprocess.js)\n *\n * Apparently, node.js serializes everything to strings when using `process.send()`, \n * so we need smart deserialization that will recreate log date and level for further processing by log4js internals.\n */\nfunction deserializeLoggingEvent(loggingEventString) {\n  var loggingEvent;\n  try {\n    loggingEvent = JSON.parse(loggingEventString);\n    loggingEvent.startTime = new Date(loggingEvent.startTime);\n    loggingEvent.level = log4js.levels.toLevel(loggingEvent.level.levelStr);\n    // Unwrap serialized errors\n    for (var i = 0; i < loggingEvent.data.length; i++) {\n      var item = loggingEvent.data[i];\n      if (item && item.stack) {\n        loggingEvent.data[i] = item.stack;\n      }\n    }\n  } catch (e) {\n    // JSON.parse failed, just log the contents probably a naughty.\n    loggingEvent = {\n      startTime: new Date(),\n      categoryName: 'log4js',\n      level: log4js.levels.ERROR,\n      data: ['Unable to parse log:', loggingEventString]\n    };\n  }\n  return loggingEvent;\n}\n\n/**\n * Creates an appender. \n *\n * If the current process is a master (`cluster.isMaster`), then this will be a \"master appender\".\n * Otherwise this will be a worker appender, that just sends loggingEvents to the master process.\n *\n * If you are using this method directly, make sure to provide it with `config.actualAppenders` array \n * of actual appender instances.\n *\n * Or better use `configure(config, options)`\n */\nfunction createAppender(config) {\n  if (cluster.isMaster) {\n    var masterAppender = function (loggingEvent) {\n      if (config.actualAppenders) {\n        var size = config.actualAppenders.length;\n        for (var i = 0; i < size; i++) {\n          if (!config.appenders[i].category || config.appenders[i].category === loggingEvent.categoryName) {\n            // Relying on the index is not a good practice but otherwise the change would have been bigger.\n            config.actualAppenders[i](loggingEvent);\n          }\n        }\n      }\n    };\n\n    // Listen on new workers\n    cluster.on('fork', function (worker) {\n      worker.on('message', function (message) {\n        if (message.type && message.type === '::log-message') {\n          // console.log(\"master : \" + cluster.isMaster + \" received message: \" + JSON.stringify(message.event));\n\n          var loggingEvent = deserializeLoggingEvent(message.event);\n\n          // Adding PID metadata\n          loggingEvent.pid = worker.process.pid;\n          loggingEvent.cluster = {\n            master: process.pid,\n            worker: worker.process.pid,\n            workerId: worker.id\n          };\n          masterAppender(loggingEvent);\n        }\n      });\n    });\n    return masterAppender;\n  } else {\n    return function (loggingEvent) {\n      // If inside the worker process, then send the logger event to master.\n      if (cluster.isWorker) {\n        // console.log(\"worker \" + cluster.worker.id + \" is sending message\");\n        process.send({\n          type: '::log-message',\n          event: serializeLoggingEvent(loggingEvent)\n        });\n      }\n    };\n  }\n}\nfunction configure(config, options) {\n  if (config.appenders && cluster.isMaster) {\n    var size = config.appenders.length;\n    config.actualAppenders = new Array(size);\n    for (var i = 0; i < size; i++) {\n      log4js.loadAppender(config.appenders[i].type);\n      config.actualAppenders[i] = log4js.appenderMakers[config.appenders[i].type](config.appenders[i], options);\n    }\n  }\n  return createAppender(config);\n}\nexports.appender = createAppender;\nexports.configure = configure;","map":{"version":3,"names":["cluster","require","log4js","serializeLoggingEvent","loggingEvent","i","data","length","item","stack","JSON","stringify","deserializeLoggingEvent","loggingEventString","parse","startTime","Date","level","levels","toLevel","levelStr","e","categoryName","ERROR","createAppender","config","isMaster","masterAppender","actualAppenders","size","appenders","category","on","worker","message","type","event","pid","process","master","workerId","id","isWorker","send","configure","options","Array","loadAppender","appenderMakers","exports","appender"],"sources":["C:/Users/malvi/Angular/template/node_modules/sql-to-json/node_modules/log4js/lib/appenders/clustered.js"],"sourcesContent":["\"use strict\";\n\nvar cluster = require('cluster');\nvar log4js = require('../log4js');\n\n/**\n * Takes a loggingEvent object, returns string representation of it.\n */\nfunction serializeLoggingEvent(loggingEvent) {\n\t// JSON.stringify(new Error('test')) returns {}, which is not really useful for us.\n\t// The following allows us to serialize errors correctly.\n\tfor (var i = 0; i < loggingEvent.data.length; i++) {\n\t\tvar item = loggingEvent.data[i];\n\t\tif (item && item.stack && JSON.stringify(item) === '{}') { // Validate that we really are in this case\n\t\t\tloggingEvent.data[i] = {stack : item.stack};\n\t\t}\n\t}\n\treturn JSON.stringify(loggingEvent);\n}\n\n/**\n * Takes a string, returns an object with\n * the correct log properties.\n *\n * This method has been \"borrowed\" from the `multiprocess` appender \n * by `nomiddlename` (https://github.com/nomiddlename/log4js-node/blob/master/lib/appenders/multiprocess.js)\n *\n * Apparently, node.js serializes everything to strings when using `process.send()`, \n * so we need smart deserialization that will recreate log date and level for further processing by log4js internals.\n */\nfunction deserializeLoggingEvent(loggingEventString) {\n\n\tvar loggingEvent;\n\t\n\ttry {\n\t\n\t\tloggingEvent = JSON.parse(loggingEventString);\n\t\tloggingEvent.startTime = new Date(loggingEvent.startTime);\n\t\tloggingEvent.level = log4js.levels.toLevel(loggingEvent.level.levelStr);\n\t\t// Unwrap serialized errors\n\t\tfor (var i = 0; i < loggingEvent.data.length; i++) {\n\t\t\tvar item = loggingEvent.data[i];\n\t\t\tif (item && item.stack) {\n\t\t\t\tloggingEvent.data[i] = item.stack;\n\t\t\t}\n\t\t}\n\n\t} catch (e) {\n\t\t\n\t\t// JSON.parse failed, just log the contents probably a naughty.\n\t\tloggingEvent = {\n\t\t\tstartTime: new Date(),\n\t\t\tcategoryName: 'log4js',\n\t\t\tlevel: log4js.levels.ERROR,\n\t\t\tdata: [ 'Unable to parse log:', loggingEventString ]\n\t\t};\n\t}\n\treturn loggingEvent;\n} \n\n/**\n * Creates an appender. \n *\n * If the current process is a master (`cluster.isMaster`), then this will be a \"master appender\".\n * Otherwise this will be a worker appender, that just sends loggingEvents to the master process.\n *\n * If you are using this method directly, make sure to provide it with `config.actualAppenders` array \n * of actual appender instances.\n *\n * Or better use `configure(config, options)`\n */\nfunction createAppender(config) {\n\n\tif (cluster.isMaster) {\n\n\t\tvar masterAppender = function(loggingEvent) {\n\t\n\t\t\tif (config.actualAppenders) {\n\t\t\t\tvar size = config.actualAppenders.length;\n\t\t\t\tfor(var i = 0; i < size; i++) {\n\t\t\t                if (!config.appenders[i].category || config.appenders[i].category === loggingEvent.categoryName) {\n\t\t\t\t\t\t// Relying on the index is not a good practice but otherwise the change would have been bigger.\n\t\t\t\t\t\tconfig.actualAppenders[i](loggingEvent);\n                    \t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Listen on new workers\n\t\tcluster.on('fork', function(worker) {\n\t\t\n\t\t\tworker.on('message', function(message) {\n\t\t\t\tif (message.type && message.type === '::log-message') {\n\t\t\t\t\t// console.log(\"master : \" + cluster.isMaster + \" received message: \" + JSON.stringify(message.event));\n\t\t\t\t\t\n\t\t\t\t\tvar loggingEvent = deserializeLoggingEvent(message.event);\n\t\t\t\t\t\n\t\t\t\t\t// Adding PID metadata\n\t\t\t\t\tloggingEvent.pid = worker.process.pid;\n\t\t\t\t\tloggingEvent.cluster = {\n\t\t\t\t\t\tmaster: process.pid,\n\t\t\t\t\t\tworker: worker.process.pid,\n\t\t\t\t\t\tworkerId: worker.id\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tmasterAppender(loggingEvent);\n\t\t\t\t}\n\t\t\t});\n\t\t\n\t\t});\n\t\t\n\t\treturn masterAppender;\n\t\t\n\t} else {\n\n\t\treturn function(loggingEvent) {\n\t\t\t// If inside the worker process, then send the logger event to master.\n\t\t\tif (cluster.isWorker) {\n\t\t\t\t// console.log(\"worker \" + cluster.worker.id + \" is sending message\");\n\t\t\t\tprocess.send({ type: '::log-message', event: serializeLoggingEvent(loggingEvent)});\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction configure(config, options) {\n\n\tif (config.appenders && cluster.isMaster) {\n\t\n\t\tvar size = config.appenders.length;\n\t\tconfig.actualAppenders = new Array(size);\n\t\n\t\tfor(var i = 0; i < size; i++) {\n\t\t\n\t\t\tlog4js.loadAppender(config.appenders[i].type);\n\t\t\tconfig.actualAppenders[i] = log4js.appenderMakers[config.appenders[i].type](config.appenders[i], options);\n\t\t\n\t\t}\n\t}\n\t\n\treturn createAppender(config);\n}\n\nexports.appender = createAppender;\nexports.configure = configure; \n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}